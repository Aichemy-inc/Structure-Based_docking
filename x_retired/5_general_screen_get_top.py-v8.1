#! /usr/bin/env python

#######################################################################
##
##	Peter M.U. Ung @ MSSM
##	
##	v1.0	- 13.11.13
##	v2.0	- 13.11.20 - add FRED tag to filename for future process
##			               FRED score is 1 decimal place
##	v3.0	- 13.11.25 - change to output number based on SDF, not score
##	v4.0	- 13.12.25 - change the read-write organization to use less 
##			               memory
##	v4.5	- 13.12.27 - fixed bug in sdf file reading added functions,
##			               read GZip and BZip2 files
##  v5.0  - 14.05.27 - change Histogram range, allow optional input
##  v6.0  - 16.12.21 - read sdf if name has "::"
##  v6.1  - 17.11.13 - chomp on SDF molname to avoid backspaces
##  v6.2  - 18.02.28 - set default upper/lower for FRED and Glide
##  v7.0  - 18.08.28 - enable SMARTS match to filter out substructures
##  v8.0  - 18.08.29 - rewrite
##  v8.1  - 18.10.30 - bugfix, SMARTS filters for selection and exclusion
##
##	Take *_score.txt generated by OpenEye FRED docking to rank molecules.
##	Then read in corresponding SDFs to select ranked molecules for output.
##	Print out the top-ranking sdf molecules and generate a histogram.	
##    -select|-exclude option enables filtering of molecules with matching
##    substructure
##
##	Required:	fred_screen_preprocess.py
##			*.fred_score.txt
##			*.fred_docked.sdf(.bz2|.gz)
##
#######################################################################

import sys
MSG = '''\n  ## Usage: x.py 
             [score files: txt] [sdf files: sdf]
             [Number of Top MOL in output: int]
             [docking software: fred | sch | etc]
             [Prefix of Output sdf, png, and txt files]\n
             [optional: -hmax=< default fred:-14.0 | sch:-10.0 >: float]
             [optional: -hmin=< default fred: -2.0 | sch:-3.0  >: float]\n
             [Optional: -coll=< X times top MOL in mem > default: 2x]
             [optional: -exclude=<SMARTS filter> (smt-clean)] removal filter
             [optional: -select=<SMARTS filter>  (smt-selec)] selection filter
             [             use when SMARTS filtering is enabled ]
         ##  TXT and SDF files can also be in GZip/BZip2 format\n
         e.g.: x.py "*_score.txt" "*.sdf" 
               1000 sch ksr-allost -hmax=-16.0 -hmin=-2.0
               -coll=3
   -exclude='C(=O)[O-]|S(=O)(=O)[O-]|P(=O)(O)[O-]'  # acidic moieties\n'''
if len(sys.argv) < 5 or len(sys.argv) > 10: sys.exit(MSG)

import glob,re,gzip,bz2,gc
from rdkit import Chem
from rdkit.Chem import AllChem
from CommonUtility import cmp
from CommonUtility import file_handle
from rdkit_grid_print import grid_print
from tqdm import tqdm

#### Default boundary constant for Histogram and changes ####
upper = -14.0
lower = -2.0
coll  = 2
grid  = False
arg_exc, arg_sel = None,None    # argument and Pattern for removal filter

for argv in sys.argv:
  if re.search(r'-exclude=', argv):
    arg_exc = argv.split('exclude=')[1]
  if re.search(r'-select=', argv):
    arg_sel = argv.split('select=')[1]

  if re.search(r'-hmax=', argv): upper = float(argv.split('=')[1])
  if re.search(r'-hmin=', argv): lower = float(argv.split('=')[1])
  if re.search(r'-coll=', argv): coll  = int(argv.split('=')[1])
  if re.search(r'-png', argv):   grid  = True

############################################################################
def doit( all_txt, all_sdf, all_top, dock, prefix ):

    # Read in .fred_score.txt
    File_Names = glob.glob(all_txt)
    print("Score File: ")
    print(File_Names)

    ## format the output name based on number of top output
    if all_top >= 1000:
      top_name = '{0}.{1}_top{2}k'.format( prefix, dock, all_top/1000 )
    else:
      top_name = '{0}.{1}_top{2}'.format( prefix, dock, all_top )

    All_Data, All_Hist = ExtractScoreInfo( File_Names )
    ## Make histogram of ditribution of FRED scores
    Histogram( All_Hist, All_Data, len(All_Data), all_top, top_name, dock, 
               upper, lower )
    print("\n  ## Finished plotting overall Top-Ranks ##\n {0} / {1}\n\n".
            format(upper, lower))

##################
    # Read in SDF file name
    SDF_Names =  glob.glob(all_sdf)
    print("SDF File: ")
    print(SDF_Names)

    ## Build a Top-Selection list, with a 3x head-room for failed molecules 
    ## must pre-select a small subset to avoid collecting too many SDF, which
    ## overload the memory and crash the system
    print("  ## User-defined output total: "+str(all_top))
    Top_Hash = {}
    Top_List = []         # [(Score, Name), ...]
    for rank, List in enumerate(All_Data):
      Top_Hash[List[1]] = List[0]
      Top_List.append(List)
      if rank == (all_top * coll): 
        break
    del All_Data
    gc.collect()
   
    ## Read in top SDF files and build ranked SDF file
    Top_sdf = CollectSDFData(SDF_Names, Top_Hash, Top_List, all_top )

    if arg_exc is None and arg_sel is None:
      WriteSDFData( Top_List, Top_sdf, all_top, top_name, dock )
    elif arg_exc is None and arg_sel is not None:
      WriteSDFDataSelect(  Top_List, Top_sdf, arg_sel, all_top, top_name, dock )
    elif arg_exc is not None and arg_sel is None:
      WriteSDFDataExclude( Top_List, Top_sdf, arg_exc, all_top, top_name, dock )
    else:
      sys.exit(' ## ERROR: Only 1 SMARTS filtering should be used ##\n')


#######################################################################
def ExtractScoreInfo( File_Names ):
  tot_en = 0  # ligand with exceedingly high energy
  All_Data, All_Hist = [], []
  
  ## From the .fred_score.txt, extract the scores for ranking
  for file_name in File_Names:
    high_en = 0 # ligand with exceedingly high energy

    print('file_name: '+file_name)
    handle = file_handle(file_name)
    with handle as f:
      for idx, l in enumerate(f):
        line = l.decode('utf-8')
        if re.search(r'Title|^#', line): 
          print("Reading...")
        else:
          try:
            num = float(line.split()[1])
            if num > 20.0:
              high_en += 1
              tot_en  += 1
            else:
              score = float(line.split()[1])
          except ValueError:
            pass
          name  = str(line.split()[0])
          All_Data.append([score, name])
          All_Hist.append(score)

        # Print the file number for every 1000 read
        if idx % 10000 == 0: print(idx)

    print('# Ligand with high energy (>20): {0}'.format(high_en))
  print('# Total Ligand with high energy (>20): {0}'.format(tot_en))
  print('# Total Ligand Collected: {0}'.format(len(All_Data)))
  All_Data.sort(lambda x,y: cmp(float(x[0]), float(y[0])))
  
  return All_Data, All_Hist


##########################################################################
## Build a database of molecules from SDF files
def CollectSDFData( SDF_Names, Top_Hash, Top_List, all_top ):
  
  ## Build a library of molecules found in the Top-Selction List
  Top_sdf = {}
  for sdf_file in tqdm(SDF_Names):
    print("  # Reading SDF file: "+sdf_file)
    sdf_handle = file_handle(sdf_file)
    Temp_sdf = [x for x in Chem.ForwardSDMolSupplier(sdf_handle,removeHs=False)
                  if x is not None]
    print('  # SDF mol read in from > {0} <: {1}'.format(sdf_file, len(Temp_sdf)))

    ## Rename ligand name if previously processed with '::' tag
    if re.search(r'::', Temp_sdf[0].GetProp('_Name')):
      print('  # Remove "::" tag from ligand name #')
      Temp_sdf = OriginalNameSDF(Temp_sdf)

    prev_name = ''
    for idx, mol in enumerate(Temp_sdf):
      if idx % 10000 == 0: 
        print(' Mol compared {0}'.format(idx))

      ## RDKit may not handle the molecules and make a 'NoneType' item
      ## 'Could not sanitize molecule ending'. Ignore this molecule
      try:
        name = mol.GetProp('_Name')
      except AttributeError:
        print("A molecule failed after this molecule ID: "+prev_name)
        continue
      prev_name = name
      if Top_Hash.get(name.rstrip()):
        Top_sdf[name.rstrip()] = mol
    del Temp_sdf    # Free memory
    gc.collect()    # active collection of memory to avoid crash

  return Top_sdf


##########################################################################
def WriteSDFData( Top_List, Top_sdf, all_top, top_name, dock ):

  Select = []
  w   = Chem.SDWriter(top_name+'.sdf')
  OUT = open(top_name+'.txt', 'w')

  ## Use the Ranked list to rebuild a consolidated SDF 
  for idx, Item in enumerate(Top_List):

    score, name = Item[0], Item[1]
    ## If mol_name has conformer number appended on it, remove _NUM
    if re.search(r'_', name):
      name = name.split('_')[0]

    if Top_sdf.get(name):
      mol = Top_sdf[name]
    else:
      print(' --> Molecule not found: {0} <--'.format(name))
      continue

    ## Rename mol name property to include data (ZINC, Rank, Score, Software)
    mol.SetProp('_Name', 
       '{0}::{1}::{2:.1f}::{3}'.format(name, idx+1, float(score), dock) )

    OUT.write('{0}\t{1}\n'.format(name, score))
    Select.append(mol)

    ## Close all files when reached the Max. output number
    if len(Select) == all_top:
      for mol in Select:
        w.write(mol) 
      print("\n ## Total Molecule Looked Thru: "+str(idx+1))
      print(' ## Total Molecule Output: '+str(len(Select)))
      OUT.close()
      w.flush()
      w.close()
      gc.collect()
      break

  if grid is True: grid_print(top_name, Select, 'sdf')


#######################################################################
# Remove molecules matching SMARTS strings into .smarts.* files until 
# reaching the targeted number of top-selected molecules
def WriteSDFDataExclude( Top_List, Top_sdf, arg_pat, all_top, top_name, dock ):

  Select, Exclude = [], []
  w   = Chem.SDWriter(top_name+'.smt-clean.sdf')
  OUT = open(top_name+'.smt-clean.txt', 'w')
#  m   = Chem.SDWriter(top_name+'.smt-excl.sdf')
#  SMA = open(top_name+'.smt-excl.txt', 'w')

  ## Use the Ranked list to rebuild a consolidated SDF 
  ## if molecule matches SMARTS filter, separate it 
  for idx, Item in enumerate(Top_List):

    score, name = Item[0], Item[1]
    ## If mol_name has conformer number appended on it, remove _NUM
    if re.search(r'_', name):
      name = name.split('_')[0]

    if Top_sdf.get(name):
      mol    = Top_sdf[name]
      switch = False

      ## Rename mol name property to include data (ZINC, Rank, Score, Software)
      mol.SetProp('_Name',
         '{0}::{1}::{2:.1f}::{3}'.format(name, idx+1, float(score), dock) )

      for smarts in [ p for p in arg_pat.split('|') ]:
        if mol.HasSubstructMatch(Chem.MolFromSmarts(smarts)):
#          print(' ** {0} matches SMARTS {1} - Skip '.format(name, smarts))
          Exclude.append(mol)
#          SMA.write(name+'\t'+str(score)+'\n')
          switch = True
          continue
      if switch:
        continue
    else:
      print(' --> Molecule not found: {0} <--'.format(name))
      continue

    OUT.write(name+"\t"+str(score)+"\n")
    Select.append(mol)

    ## Close all files when reached the Max. output number
    if len(Select) == all_top:
      for mol in Select:
        w.write(mol)
#      for mol in Exclude:
#        m.write(mol)
      print("\n ## Total Molecule Looked Thru: "+str(idx+1))
      print(' ## Molecule Selected: '+str(len(Select)))
      print(' ## Molecule Matched {0}: {1}'.format(arg_exc,len(Exclude)))
      OUT.close()
#      SMA.close()
      w.flush()
      w.close()
#      m.close()
      gc.collect()
      break

  if grid is True: grid_print(top_name, Select, 'sdf')


#######################################################################
# *Select* molecules matching SMARTS strings into .smarts.* files until 
# reaching the targeted number of top-selected molecules
def WriteSDFDataSelect( Top_List, Top_sdf, arg_pat, all_top, top_name, dock ):

  Others, Matched = [], []
  #w   = Chem.SDWriter(top_name+'.smt-filt.sdf')
  #OUT = open(top_name+'.smt-filt.txt', 'w')
  m   = Chem.SDWriter(top_name+'.smt-selec.sdf')
  SMA = open(top_name+'.smt-selec.txt', 'w')

  ## Use the Ranked list to rebuild a consolidated SDF 
  ## if molecule matches SMARTS filter, separate it 
  for idx, Item in enumerate(Top_List):

    score, name = Item[0], Item[1]
    ## If mol_name has conformer number appended on it, remove _NUM
    if re.search(r'_', name):
      name = name.split('_')[0]

    if Top_sdf.get(name):
      mol    = Top_sdf[name]
      switch = False

      ## Rename mol name property to include data (ZINC, Rank, Score, Software)
      mol.SetProp('_Name',
         '{0}::{1}::{2:.1f}::{3}'.format(name, idx+1, float(score), dock) )

      for smarts in [ p for p in arg_pat.split('|') ]:
        if mol.HasSubstructMatch(Chem.MolFromSmarts(smarts)):
          Matched.append(mol)
          SMA.write('{0}\t{1}\n'.format(name, score))
          switch = True
          break
      if not switch:
#        print(' ** {0} not match SMARTS {1} - Skip '.format(name, arg_pat))
        Others.append(mol)
#        OUT.write('{0}\t{1}\n'.format(name, score))
    else:
      print(' --> Molecule not found: {0} <--'.format(name))
      continue

    ## Close all files when reached the Max. output number
    if len(Matched) == all_top or idx == len(Top_List)-1:
#      for mol in Others:
#        w.write(mol)
      for mol in Matched:
        m.write(mol)
      print("\n ## Total Molecule Looked Thru: "+str(idx+1))
      print(' ## Molecule Not Matched: '+str(len(Others)))
      print(' ## Molecule Matched {0}: {1}'.format(arg_sel,len(Matched)))
#      OUT.close()
      SMA.close()
#      w.flush()
#      w.close()
      m.close()
      gc.collect()
      break

  if grid is True: grid_print(top_name, Matched, 'sdf')


#######################################################################
## if "ligand name" has '::' due to previous rdkit processing, remove the
## added data and just the "name" again
def OriginalNameSDF(sdfs):
  NewData = []
  for mol in sdfs:
    name = mol.GetProp('_Name')
    mol.SetProp('_Name', name.split('::')[0])
    NewData.append(mol)
  return NewData


#######################################################################
## Plot Histogram of Score distribution
def Histogram(Histo, Part, num_mol, top, top_name, dock, UPPER, LOWER ):
    import numpy as np
    import matplotlib.pyplot as plt

    ## if input top number is larger than database size:
    if len(Part) < top:
      tmp_top = len(Part)
    else:
      tmp_top = top

    bin_upper = UPPER
    bin_lower = LOWER
    bin_size  = 0.2
    text_high = num_mol/22.5
    text_hori = 0.3
   
    i = bin_upper
    Bins_Range = []
    while i < bin_lower:
        Bins_Range.append(i)
        i = i+bin_size

    fig, ax = plt.subplots()
    plt.figure(num=1, figsize=(8,6), dpi=150)

    ax.hist(Histo, Bins_Range, histtype='step', color='0.25')
    plt.xlabel(dock.upper()+' Score')
    plt.ylabel('No. of Molecule')
    plt.title( top_name+": "+str(num_mol) )
    plt.xlim([UPPER, LOWER])

    ## Draw a vertical line to indicate the Top hits
    ax.axvline( x=Part[tmp_top-1][0], ymin=0, ymax=1000, 
                color='r', linewidth=2 )
    top_num = 'Top '+str(top)+': '+str(Part[tmp_top][0])
    ax.text( Part[tmp_top-1][0]-text_hori, text_high, 
             top_num, rotation=90, color='b' )
    print(top_num)

    ## Draw a vertical line to indicate the Median Score
    ax.axvline( x=np.median(Histo), ymin=0, ymax=1000, 
                color='b', linewidth=2 )
    median = 'Median: '+str(np.median(Histo))
    ax.text( np.median(Histo)-text_hori, text_high, 
             median, rotation=90, color='b' )
    print(median)

    ## Draw 2 vertical lines to indicate the standard deviation
    ax.axvline( x=(np.median(Histo)+np.std(Histo)), 
                ymin=0, ymax=1000, color='k', linewidth=1.2 )
    ax.axvline( x=(np.median(Histo)-np.std(Histo)), 
                ymin=0, ymax=1000, color='k', linewidth=1.2 )
    stdev = 'StDev: '+str(np.around(np.std(Histo), decimals=2) )
    ax.text( np.median(Histo)+np.std(Histo)-text_hori, text_high, 
             stdev, rotation=90, color='k' )
    print(stdev)

#    plt.show()
    plt.savefig( top_name+'.histo.png', dpi=150 )
    plt.close()


############################################################################
if __name__ == '__main__':
    doit( sys.argv[1], sys.argv[2], int(sys.argv[3]), sys.argv[4], sys.argv[5] )
